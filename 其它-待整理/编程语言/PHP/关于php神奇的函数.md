```php
fastcgi_finish_request()
```

- 此函数冲刷(flush)所有响应的数据给客户端并结束请求。 这使得客户端结束连接后，需要大量时间运行的任务能够继续运行。
- 这个在`php5.3.3`加入的函数，带上了一点异步的思想，但是坑大于利，属于鸡肋，但在某些特殊场合能简化操作
- 需要注意的点
	
	- 	在`fastcgi_finish_request（）`之后，该脚本仍将占用`FPM`进程。 因此，对于长时间运行的任务过度使用它可能会占用所有`FPM`线程，直到`pm.max_children`。 这将导致`Web`服务器上的网关错误。
	- 	另一个重要的事情是会话处理。 只要它们处于活动状态，会话就会被锁定（请参阅`session_write_close（）`的文档）。 这意味着后续请求将会阻塞，直到会话关闭。
	- 	因此，您应该尽快调用`session_write_close（）`（甚至在`fastcgi_finish_request（）`之前）以允许后续请求和良好的用户体验。
	- 	这也适用于所有其他锁定技术，例如`flock`或数据库锁。 只要锁定处于活动状态，后续请求就会出现问题。
	- 	还需要将 调整脚本最大执行时间 来支持它跑完
	
## `MVC` 模式 的发展

- 架构是演进出来的这句话真的是良言，从 web MVP 到 web mvc 再到 mc  mvvm 后端作为服务提供者
- 优劣不说，都是为了解决对应的问题，而产生的一种模型
- `We need SMART Models, THIN Controllers, and DUMB Views` 这大概是mvc的终极目标 智能Model 瘦controller 还有 前端模板
- 后来者 在 mc 上 发展出 model controller service 之类的更明确的分层， view 在 nginx 的加持下自成一体，前后端组件化的思想，更加明确
- 而后端将 Service 分层 从 单体到分布式，进行大量的改造将一次请求过程中所涉及的部分，都进行抽象与隔离，最终形成微服务架构
- 但对于大多数的公司的单体应用来说，只要数据 /逻辑 /服务 这三层能隔离开才有向下一步进行改造的资质
- 上层不关心下层，同级之间不能相互调用 ，有这样的思想才能写出可扩展的程序