- 分析查询速度慢的原因
    - 分析sql查询慢的方法 慢查询日志
    - 使用pt-query-digest工具进行分析
    - show profile
        - set profiling = 1;开启
        - 服务器上执行的所有sql语句所消耗的时间,都会被存在临时表中
        - show profiles
        - show profile for query 临时表ID
    - show status 会返回操作的一些计数器
    - show processlist 观察线程是否处于不正常的状态
    - explain 分析单条的sql语句
    - desc select * from a  和explain一样
- 优化查询过程中的数据访问
    - 
    - 访问数据量太大导致性能下降
    - 需要什么字段查什么字段 数据的读写,传输也会耗时间
    - 确认mysql服务器是否在分析大量不必要的数据行
        - 避免查询不需要的数据 使用limit限制
        - 多表关联 只返回需要的列
        - select * 会导致索引无法覆盖数据的全部列
        - 总之 按需取数据
    - 重复查询相同的数据 ,可以缓存数据,下次直接读缓存,减轻数据库的压力
    - 改变数据库和数据表的结果,修改数据表达式
        - 比如说第三范式 需要关联另一张的表的某个字段,那么我们就可以把这个字段冗余的写入另一张表来减少关联查询
        - 
- 优化长难的查询语句
    - 
    - mysql内部每秒能扫描内存中上百万数据,相比之下,响应数据给客户端要慢得多
        - 使用尽可能少的查询是好的,但是有时候将一个大的sql分解为小sql也是有必要的
    - 切分查询
        -  将一个大的查询分解为许多个相同的小查询
        -  比如说删除1000W数据,多次删除一W要比一次性删完要节省服务器开销(执行时间长会锁表)
    -   分解关联查询
        - 可以将一条sql分解成多条sql执行
        - 让缓存效率变高
        - 执行单个查询可以减少锁的竞争
        - 在应用层做关联 方便以后多数据库进行拆分
- 优化特定类型的查询语句
    - 
    - 优化count(`*`)中的`*`专门做过优化 会忽略所有行,直接统计行数,因此不要使用count(列名)
        - Myisam中,没有任何where条件的count(*)非常快
        - 但是有了where条件 效率就和其他引擎类似了
        - 可以使用explain查近似值来替代count(*)
        - 增加汇总表 增加更新加一
        - 使用缓存
    - 优化关联查询
        - 确定on后面的子句的列上是有索引的
        - 确保group by 和 order by 中只有一个表的列,如果groupby 了两张表的列,那么是无法使用索引的
        - 优化子查询 (用关联查询替代子查询)
        - 关联查询中用索引列效率会更高
        - 如果group后不需要排序  那么就在后面加上 order by null mysql就不会对文件进行排序了
    - 优化limit 分页
        - 加where(id> 100) limit 100,200;
    - 优化union all
    - 可以在程序里面去重
`请简述项目中优化sql执行效率的方法,从哪些方面,sql语句性能如何分析?`
```
1. 先定位 低效sql语句
2. 先从索引 入手
3. 如果索引 没有问题 
4. 考虑上面的三类方案
```
